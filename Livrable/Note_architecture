ğŸ§± DÃ©coupage en responsabilitÃ©s
1. UI (ui.py)

Gestion de lâ€™interface Tkinter

Rendu, thÃ¨mes, labels, TreeView

Interactions utilisateur

RafraÃ®chissement des donnÃ©es

âŒ Aucun appel rÃ©seau directement dans lâ€™UI
â†’ Bon respect du dÃ©couplage.

2. API (almanax_api.py)

Appels HTTP vers lâ€™API Dofus

Parsing JSON

Normalisation des donnÃ©es (format commun interne)

â†’ Le module expose une seule fonction :
fetch_almanax(offset)
âœ” SimplicitÃ©
âœ” Facile Ã  mocker

3. Utils (utils.py)

Fonctions gÃ©nÃ©riques et sans dÃ©pendance : formatage de date

Pas de logique mÃ©tier

â†’ Conforme aux bonnes pratiques.

4. main.py

Point dâ€™entrÃ©e

Bootstrapping Tkinter

ZÃ©ro logique mÃ©tier
âœ” Minimal, propre

ğŸ”— DÃ©pendances & flux de donnÃ©es
UI  â†’  API (fetch data)
UI  â†’  Utils (format)
API â†’  requests (lib externe)


Aucun import croisÃ© â†’ architecture saine.

ğŸ§  Choix dâ€™architecture (KISS / DRY / YAGNI)
âœ” KISS (Keep It Simple, Stupid)

Pas de classes complexes

Pas dâ€™hÃ©ritage inutile Tkinter

Un seul fichier pour lâ€™API

Aucun pattern overkill (MVC, MVVMâ€¦ inutile ici)

âœ” DRY (Donâ€™t Repeat Yourself)

fetch_almanax() centralise tous les appels API

Formatage de date isolÃ© dans utils

Style Tkinter regroupÃ© dans apply_custom_theme()

âœ” YAGNI (You Arenâ€™t Gonna Need It)

Ce qui a volontairement Ã©tÃ© non implÃ©mentÃ© :

Mise en cache locale

Multi-langues

Fichiers de configuration

Tests unitaires avancÃ©s

Gestion dâ€™Ã©tat complexe

â†’ Correct pour une application simple et mono-Ã©cran.

ğŸ”§ AmÃ©liorations possibles

Externaliser le thÃ¨me dans theme.py

Introduire un fichier config.py pour les constantes

Ajouter un logger rÃ©el (logging)

ImplÃ©menter un cache mÃ©moire